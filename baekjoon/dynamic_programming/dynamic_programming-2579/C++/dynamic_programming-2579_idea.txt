마지막계단 반드시 밟아야 한다..
마지막부터 시작해서 ㄱㄱ?

dp[0] = stair[0]

1번을 밟으면 2번을 밟을 수없음
2번을 밟으면


dp[n] = max(stair[n-1]+stair[n-3] or stair[n-2]+stair[n-3]) +stair[n]
---

문제 분석:

계단은 한 번에 1개 또는 2개씩 오를 수 있습니다.
연속된 3개의 계단을 모두 밟을 수 없습니다.
마지막 계단은 반드시 밟아야 합니다.


DP 접근 방식:

dp[i]를 i번째 계단까지 올랐을 때 얻을 수 있는 최대 점수라고 정의합니다.
하지만 이것만으로는 부족합니다. 연속된 3개의 계단을 밟지 않아야 한다는 조건 때문입니다.


개선된 DP 접근:

dp[i][j]를 정의합니다. 여기서:

i는 현재 계단의 번호
j는 연속으로 밟은 계단의 수 (1 또는 2)


따라서:

dp[i][1]: i번째 계단을 밟고, 직전 계단을 밟지 않았을 때의 최대 점수
dp[i][2]: i번째 계단을 밟고, 직전 계단도 밟았을 때의 최대 점수




DP 점화식:

dp[i][1] = max(dp[i-2][1], dp[i-2][2]) + stairs[i]
(i-2번째 계단에서 2칸 점프해서 현재 계단으로 온 경우)
dp[i][2] = dp[i-1][1] + stairs[i]
(i-1번째 계단에서 1칸 점프해서 현재 계단으로 온 경우, 단 i-1은 반드시 첫 번째로 밟은 계단이어야 함)


초기 조건:

dp[1][1] = stairs[1]
dp[1][2] = 0 (불가능한 경우)
dp[2][1] = stairs[2]
dp[2][2] = stairs[1] + stairs[2]


최종 결과:

N번째 계단에서의 최대 점수: max(dp[N][1], dp[N][2])


구현 시 주의사항:

계단 번호를 1부터 시작하는 것이 편리합니다.
입력받은 계단 점수를 배열에 저장합니다.
dp 배열은 2차원으로 [계단 수 + 1][3] 크기로 선언합니다.


시간 복잡도:

O(N), 여기서 N은 계단의 수입니다.